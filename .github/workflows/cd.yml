name: ProductService_CD

on:
  push:
    branches: [master]
    # 只有当CI通过并且代码已经合入master时才触发CD
  workflow_run:
    workflows: ["ProductService_CI"]
    types:
      - completed
    branches: [master]

jobs:
  deploy:
    runs-on: ubuntu-latest
    # 只有当CI workflow成功完成时才运行部署
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Docker Images for Deployment
        run: |
          echo "🔨 强制重新构建ProductService镜像..."
          # 构建ProductService后端镜像，使用commit SHA作为唯一标签
          docker build --no-cache -t productservice-backend:${{ github.sha }} .
          docker tag productservice-backend:${{ github.sha }} productservice-backend:latest

          echo " 保存应用镜像文件..."
          # 只保存应用镜像，数据库镜像在服务器端处理
          docker save productservice-backend:latest | gzip > product-service.tar.gz

          echo "✅ 应用镜像构建完成，版本: ${{ github.sha }}"

      - name: Create K3s deployment package
        run: |
          mkdir -p k3s-deploy
          cp -r k8s/* k3s-deploy/
          cp product-service.tar.gz k3s-deploy/
          cp docker-compose.yml k3s-deploy/

          # 创建部署脚本
          cat > k3s-deploy/deploy-to-k3s.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "🚀 开始部署 ProductService 到 K3s..."
          echo "📦 部署版本: ${{ github.sha }}"
          echo "🔧 部署时间: $(date)"

          # 设置kubectl别名
          alias kubectl='k3s kubectl'

          # 确保PostgreSQL镜像存在（首次部署或按需拉取）
          echo "🔍 检查PostgreSQL镜像..."
          if ! k3s ctr images list | grep -q "docker.io/library/postgres:14"; then
            echo "📥 拉取PostgreSQL镜像..."
            k3s ctr images pull docker.io/library/postgres:14
          else
            echo "✅ PostgreSQL镜像已存在，跳过拉取"
          fi

          # 加载应用镜像到K3s
          echo "📥 加载应用镜像..."

          # 先删除旧的应用镜像（如果存在）
          echo "🗑️ 清理旧的应用镜像..."
          k3s ctr images rm docker.io/library/productservice-backend:latest 2>/dev/null || true

          echo "导入ProductService后端镜像..."
          k3s ctr images import product-service.tar.gz

          # 验证镜像导入
          echo "🔍 验证镜像导入..."
          k3s ctr images list | grep -E "(productservice-backend|postgres)"

          # 在镜像导入后kill掉现有的product-service pod以强制重新拉取新镜像
          echo "🔄 强制重启product-service pod以使用新镜像..."
          k3s kubectl delete pods -l io.kompose.service=product-service --ignore-not-found=true

          # 应用K8s配置
          echo "🔧 应用K8s配置..."
          k3s kubectl apply -f postgres-data-persistentvolumeclaim.yaml
          k3s kubectl apply -f db-deployment.yaml
          k3s kubectl apply -f db-service.yaml

          # 等待数据库启动
          echo "⏳ 等待数据库启动..."
          k3s kubectl wait --for=condition=ready pod -l io.kompose.service=product-db --timeout=300s || {
            echo "❌ 数据库启动超时，检查日志..."
            k3s kubectl describe pod -l io.kompose.service=product-db
            k3s kubectl logs -l io.kompose.service=product-db --tail=50
            exit 1
          }

          # 部署后端服务
          echo "🔧 部署后端服务..."

          # 先删除旧的部署（强制更新）
          echo "🔄 强制更新部署..."
          k3s kubectl delete deployment product-service 2>/dev/null || true
          k3s kubectl delete pods -l io.kompose.service=product-service 2>/dev/null || true

          # 等待旧Pod完全删除
          echo "⏳ 等待旧Pod清理..."
          k3s kubectl wait --for=delete pod -l io.kompose.service=product-service --timeout=60s || true

          # 部署新版本
          echo "🔧 部署后端Deployment..."
          k3s kubectl apply -f backend-deployment.yaml
          
          echo "🔧 部署后端Service..."
          # 检查端口是否被占用
          echo "🔍 检查NodePort 30800是否被占用..."
          k3s kubectl get services --all-namespaces -o wide | grep 30800 && echo "⚠️ 端口30800已被占用" || echo "✅ 端口30800可用"
          
          k3s kubectl apply -f backend-service.yaml || {
            echo "❌ Service部署失败，检查详情..."
            k3s kubectl describe service product-service || echo "Service不存在"
            exit 1
          }
          
          # 验证Service是否创建成功
          echo "🔍 验证Service创建..."
          sleep 2  # 等待Service创建完成
          if k3s kubectl get service product-service > /dev/null 2>&1; then
            echo "✅ product-service Service创建成功"
            k3s kubectl get service product-service -o wide
            echo "🔍 检查Service端点..."
            k3s kubectl get endpoints product-service || echo "⚠️ 端点未就绪"
          else
            echo "❌ product-service Service创建失败"
            echo "📋 当前所有Services:"
            k3s kubectl get services -o wide
            echo "📋 检查Service创建事件:"
            k3s kubectl get events --field-selector involvedObject.kind=Service --sort-by='.lastTimestamp' | tail -10
            exit 1
          fi
          
          # 部署HPA（需要在Deployment存在后）
          echo "🔧 部署HPA自动扩缩容..."
          k3s kubectl apply -f HPA.yaml

          
          # 等待后端服务启动
          echo "⏳ 等待后端服务启动..."
          k3s kubectl wait --for=condition=ready pod -l io.kompose.service=product-service --timeout=300s || {
            echo "❌ 后端服务启动超时，检查日志..."
            k3s kubectl describe pod -l io.kompose.service=product-service
            k3s kubectl logs -l io.kompose.service=product-service --tail=50
            exit 1
          }

          # 检查部署状态
          echo "📊 检查部署状态..."
          echo "📋 Pods状态:"
          k3s kubectl get pods
          echo "📋 Services状态:"
          k3s kubectl get services -o wide
          echo "📋 HPA状态:"
          k3s kubectl get hpa
          echo "📋 NodePort服务详情:"
          k3s kubectl get services --field-selector spec.type=NodePort -o wide
          
          # 验证HPA状态
          echo "🔍 验证HPA状态..."
          k3s kubectl describe hpa product-service-hpa || echo "⚠️ HPA描述失败，可能需要时间初始化"
          # 等待HPA准备就绪
          echo "等待HPA准备就绪..."
          k3s kubectl wait --for=condition=established hpa/product-service-hpa --timeout=60s 2>/dev/null || true
          # 获取服务端口
          NODE_PORT=$(k3s kubectl get service product-service -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30800")
          echo "✅ ProductService 部署完成！"
          echo "🌐 访问地址: http://101.132.163.45:$NODE_PORT"
          echo "💚 健康检查: http://101.132.163.45:$NODE_PORT/health/"

          # 健康检查
          echo "🏥 执行健康检查..."
          for i in {1..10}; do
            if curl -f http://localhost:$NODE_PORT/health/ > /dev/null 2>&1; then
              echo "✅ 健康检查通过！"
              break
            elif [ $i -eq 10 ]; then
              echo "⚠️ 健康检查失败，但服务可能仍在启动中"
              echo "📋 最近的Pod日志:"
              k3s kubectl logs -l io.kompose.service=product-service --tail=20
            else
              echo "⏳ 等待服务完全启动... ($i/10)"
              sleep 15
            fi
          done

          echo "🎉 ProductService CD 部署流程完成！"
          EOF

          chmod +x k3s-deploy/deploy-to-k3s.sh

          # 打包部署文件
          tar -czf ProductService.tar.gz k3s-deploy/

      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Deploy to K3s Server
        run: |
          echo "🚀 开始部署到生产服务器..."

          # 上传部署包到服务器
          sshpass -p "${{ secrets.ECS_PASSWORD }}" scp -o StrictHostKeyChecking=no \
            ProductService.tar.gz \
            root@${{ secrets.ECS_IP }}:/tmp/

          # 在服务器上执行部署
          sshpass -p "${{ secrets.ECS_PASSWORD }}" ssh -o StrictHostKeyChecking=no root@${{ secrets.ECS_IP }} "
            echo '🔧 开始服务器端部署...'

            
            # 解压新的部署包
            cd ~
            tar -xzf /tmp/ProductService.tar.gz
            mv k3s-deploy ProductService
            cd ProductService
            
            echo '🚀 执行部署脚本...'
            # 执行部署脚本
            ./deploy-to-k3s.sh
            
            # 清理临时文件
            rm -f /tmp/ProductService.tar.gz
            
            echo '✅ K3s ProductService 部署完成!'
            echo '📊 最终服务状态:'
            k3s kubectl get pods,services | grep product
          "

          echo "🎉 CD 部署流程完成！"

      - name: Deployment Summary
        run: |
          echo "📋 部署摘要:"
          echo "🔖 版本: ${{ github.sha }}"
          echo "🌿 分支: ${{ github.ref_name }}"
          echo "⏰ 时间: $(date)"
          echo "🌐 访问地址: http://101.132.163.45:30800"
          echo "💚 健康检查: http://101.132.163.45:30800/health/"
